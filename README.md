XmlViewAddin
============

# Disclaimer
The following document and all the code in this repository are not part of the LoadRunner product!
You are using the code and data and the products generated by compiling this code at your own risk.

# General
I am going to create a new VuGen addin which allows you to view	XML content in
a separate window directly from the script. My goal is not to provide some highly
useful functionality but to introduce you to the VuGen extensibility mechanism.

## Addins
### Directory Structure
VuGen 11.5x is based on [SharpDevelop 4.1](http://www.icsharpcode.net/opensource/sd/) and therefore it 
uses the SharpDevelop (SD) extensibility layer. We added an additional layer of services but more on that later.
VuGen itself contains only the core extensibility layer and the application starter, all the other functionality
including code editing, recording, replaying, script management, etc... are extensions to VuGen written in the same
way I am going to present here. All the extensions are defined in the *%LR_DIR%\addins* directory through the use of
```.addin``` files. Under the aforementioned directory you can find the following core addins:

* ```ICSharpCode.SharpDevelop.addin``` - Defines the basic UI structures we take from SharpDevelop (e.g. main menu, main toolbar, etc...).

* ```VuGenGeneralUI.addin``` - Defines VuGen specific UI structures for generic use (e.g. search).

* ```VuGenBackEnd.addin``` - Defines functionality needed for VuGen business logic.

The rest of the addins are distributed throughout the subdirectories by topic.
As you can see, VuGen is separated into three layers - SharpDevelop, Utt, and VuGen. The reason
for this separation is not important to this discussion.

### Some useful terms
By now you are familiar with the term ```addin``` but where do those addins go? The addins
are combined during the application startup into one big tree-like structure known as the 
```addin-tree```. The addin tree is built of nodes where each node contains ```codons```. A ```codon```
is basically a piece of code that "knows" how to do something. For example, if I want to add a new menu item
I create a ```codon``` which implements an interface of a menu item (I show an example of this later) and add a
definition of that ```codon``` to the appropriate place in the addin file. To tell the addin tree to which node we want
to add our ```codon```, we use the ```path``` property which is a concatenated list of all the nodes in the route to the target node.
The path uses the ```id``` property of any ```codon``` to generate a new node for this ```codon``` so essentially each ```codon``` generates
a node in the tree. For example, if I want to add my menu item into the main menu of the application, I should put it into the ```/SharpDevelop/Workbench/MainMenu``` path.
This path basically reads, root -> SharpDevelop -> Workbench -> MainMenu node.


### Addin file structure
The addin file is a simple XML file with a predefined structure. I briefly describe the most
important (and mandatory) parts of this file but you can always learn more from the SD website.
The following is an example of a simple addin file:
```xml
<AddIn name = "XmlViewAddin"
       author = "Boris Kozorovitzky"
       description = "Adds the functionality to easily view XML data directly from the editor">
  
  <Runtime>
    <Import assembly = "XmlViewAddin.dll"/>
  </Runtime>

  <Manifest>
    <Identity name="XmlViewAddin" version = "0.0.1.0" />
  </Manifest>

  <Path name = "/SharpDevelop/Workbench/MainMenu">
    <MenuItem id = "MenuItemTest" label = "TEST!" type="Menu"></MenuItem>
  </Path>

</AddIn>
```

The main element ```<AddIn>``` contains basic information on the the addin file and the author.
Inside we find the ```<Runtime>``` element. This element is very important because it links the 
```.addin``` file with all the dlls implementing its functionality. In this example I import only
the dll which I am going to produce for this addin example called ```XmlViewAddin.dll```. You can specify
as many dlls as you need in this section, each in its own ```<Import>``` element.

The ```<Manifest>``` element contains the metadata about your addin. In the example I specify only the
identity of my addin and the version number. This is a mandatory element because it is needed to register
your addin with the extensibility layer.

The ```<Path>``` element tells the extensibility layer where to put the ```codons``` within the Addin-Tree.
In the example we can see that we add a menu item with the label "TEST!" to the main menu of our application.

## Writing your own addin
In this section I describe the process of writing my addin. I am using Visual Studio 2010 but
you can do it in any editor. Specifically, we ship VuGen with SharpDevelop 4.1 (including sources) so
you can just install that from the LR DVD here ```\Additional Components\Third Parties\SharpDevelop_4_1_src\SharpDevelop-4.1.0.8000.zip```.

I start by creating a C# class library and adding a ```.addin``` file to it. You can use any .Net language
as long as you compile to framework 4 (or above). My addin file contains the XML from the example above.
The next thing I do is to configure the class library to be built into the following folder: *%LR_DIR%\addins\extra\XmlViewAddin*
(create this folder manually first) and the build action of my ```.addin``` file to _Copy always_. This will copy the 
update version of my addin directly to VuGen every time I build it. 
For easier debugging I set the Start Action of my debugger to start VuGen by pointing it to *%LR_DIR%\bin\vugen.exe*.
Run the addin (press F5), a VuGen should start and the main menu should contain our item:

![VuGen with the new menu item](/img/i1.png "VuGen with the new menu item")

In the next sections I try to use as little "inside" knowledge as possible although this is
not always possible.

## Step 1 - Adding a context menu command
In this step we add a menu item to the context menu of the editor. We start by adding a menu item
to the context menu of the editor pane. To do this we must first find the ```path``` of this
context menu. We open an empty script and right click the editor to see where we want to place 
the menu item, it seems that the best place is right after the "Go to Step in Replay log" item. 
We search for the item name throughout all the ```.addin``` files. We found one instance of this string
in the ```VuGenDebugger.addin``` so lets copy it to our addin file with the relevant changed.

```xml
  <Path name = "/SharpDevelop/ViewContent/TextEditor/ContextMenu">
    <MenuItem id="OpenXmlView" insertafter="GoToLine" insertbefore="InsertSeparator"
            label = "Open in XML viewer"
            class = "XmlViewAddin.OpenXmlViewCommand"/>
  </Path>
```

A few things to notice here:

* The *insertbefore* and *insertafter* attributes control where our menu item is added. We cannot set the
exact position (which is good, because we don't know what other addins might want to be added to that position)
but we can suggest where this menu item is added based on the ids of the codons before and after. In this case, our
menu item is added somewhere after the *GoToLine* ```codon``` but before the *InsertSeparator* which means it is added
right after the *GoToLine* ```codon```.

* The path we use is the same path as the *GoToLine* ```codon```.

* The *class* attribute points to the name of the class of the actual implementation. I created
a new class named *OpenXmlViewCommand* in the *XmlViewAddin* namespace.

* By definition, each class that has the menu item functionality must inherit from the *ICommand* interface
of SD. We have created a set of more convenient wrappers which are not mandatory to use. In this case we use the
*UttBaseWpfCommand* implementation class for the *ICommand* interface as the base class for our command. To do this we
have to reference the following dlls: ```ICSharpCode.Core.dll``` and ```HP.Utt.Core.dll``` from *%LR_DIR%\bin* and ```PresentationCore``` from the GAC.
Remember to set the "Copy local" property to ```false``` since we compile into the LoadRunner directory anyway.

Our code looks something like this:
```c#
using System;
using HP.Utt.UttCore;

namespace XmlViewAddin
{
  public class OpenXmlViewCommand : UttBaseWpfCommand
  {
    public override void Run()
    {
      throw new NotImplementedException();
    }
  }
}
``` 

We can verify that the menu item "works" by running our addin and in VuGen right-clicking 
anywhere in the editor. In the context menu we select the "Open in XML viewer" menu item and
see an error dialog (since we throw an exception in the *Run* method).

## Step 2 - Get the selected text from the editor
In this step we get the selected text from the editor so that we can parse it into XML. To this end
we will use the *UttCodeEditor* wrapper around the code editor. To use it we need some additional references
for our project. Add the following dlls to the references: ```ICSharpCode.SharpDevelop.dll``` and ```HP.Utt.CodeEditor.dll``` 
(don't forget to set "Copy local" to false). Now we can simply use this code 

```c#
      ITextEditor editor = UttCodeEditor.GetActiveTextEditor();
      if (editor == null)
        return;
```

to retrieve the current editor. The editor object has a *SelectedText* property which we use to get, as the name implies, the 
selected text.

## Step 3 - Infer the XML value
We want to convert the selected text to a valid XML string. Specifically, we are interested in Soap
request strings which come escaped. The following code is a simple algorithm to trim out the 
unneeded parts from that string.

```c#
      string[] lines = editor.SelectedText.Split(new string[]{Environment.NewLine},StringSplitOptions.RemoveEmptyEntries);
      StringBuilder result = new StringBuilder();
      foreach (string line in lines) 
      {
        string proccessedLine = line.Trim();
        //Remove the leading and trailing " - this is VuGen specific code
        if (proccessedLine.StartsWith("\""))
        {
          proccessedLine = proccessedLine.Remove(0, 1);
        }
        if (proccessedLine.EndsWith("\""))
        {
          proccessedLine = proccessedLine.Remove(proccessedLine.Length-1, 1);
        }
        proccessedLine = proccessedLine.Replace("\\","");
        
        result.Append(proccessedLine);
      }
``` 

At the end of the process we should have the selected value correctly in the *result* ```StringBuilder```.
To verify that the result is a valid XML document we add a small static verification method *IsValidXml* before
we pass the read XML to the display component. The code looks something like this:

```c#
    public static bool IsValidXml(string xml)
    {
      XmlDocument doc = new XmlDocument();
      try
      {
        doc.LoadXml(xml);
      }
      catch
      {
        return false;
      }

      return true;
    }
```

(perhaps not the best code but good enough for our discussion)

## Step 4 - Show the XML in a nice way
Now that we have the XML string we want to show it nicely in a modal dialog. We could o
pen a regular dialog and use a textbox to display the XML but we can simply reuse the VuGen dialogs
framework and the VuGen XML viewer to display our information. First we add the dialogs framework, we reference
the following dlls: ```HP.Utt.Dialog.dll```, ```HP.Utt.Common.dll```, and ```HP.LR.VuGen.Common.dll``` from *%LR_DIR%\bin\* and ```PresentationFramework```, ```System.Xaml```, and ```WindowsBase```
from the GAC (the later three are needed to use the WPF framework and are not directly related to VuGen).
Next, we reference the VuGen XML viewer component conveniently named ```HP.LR.VuGen.XmlViewer.dll``` from
*%LR_DIR%\bin\*.

At this point things get a little tricky, not because of bad API but because of naming. The ```CustomDialog``` 
class is a container for all your dialog needs. We can set its content to any WPF control we want and it will display it.
Moreover, we have various services the ```CustomDialog``` provides for us such as buttons, persistence, and much more.
In the dialog we place the VuGen XML viewer named ```XmlViewSingleContent``` (yes, I know this name is very confusing). Since
we are using the MVVM development paradigm the ```XmlViewSingleContent``` expects a view-model of type ```SingleDirectionData```
(again, very confusing). The view-model takes an ```XmlDocument``` class which we can easily create from our XML string.
The code is therefore looks like this:

```c#
    private void ShowXmlDialog(string xml)
    {
      CustomDialog dialog = new CustomDialog();
      XmlViewSingleContent content = new XmlViewSingleContent();
      SingleDirectionData data = new SingleDirectionData();
      content.DataContext = data;
      XmlDocument doc = new XmlDocument();
      doc.LoadXml(xml);
      data.Document = doc;
      dialog.Content = content;
      dialog.Show();
    }
```
I call the above method with the string we calculated in the ```Run``` method and the result is like this:

![VuGen displays my XML](/img/i2.png "VuGen displays my XML")